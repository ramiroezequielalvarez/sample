private implementationDateFilter(date: moment.MomentInput | null): boolean {
  date = date ?? moment();
  const isAdmin = this.sharedSecurityService.getRoleAccess().isActingAdminRole();

  // Obtener el día hábil anterior
  let startDate = moment().subtract(1, 'days');
  while (startDate.isoWeekday() > 5) { // Si es sábado (6) o domingo (7), retroceder hasta el viernes (5)
    startDate.subtract(1, 'days');
  }

  return moment(date).isoWeekday() >= 1 && moment(date).isoWeekday() <= 5 && moment(date).isSameOrAfter(startDate);
}





INSERT INTO liabilitybmk."ExternalManagerClientSolutions" 
("ExternalManagerId", "ClientSolutionId", "StartDate", "EndDate")
SELECT 
    em."Id" AS "ExternalManagerId",
    cs."EntityId" AS "ClientSolutionId",
    emc."ImplementationDate" AS "StartDate",
    emc."TerminationDate" AS "EndDate"
FROM "ExternalManagers" AS em
INNER JOIN "ExternalManagerConfigs" AS emc 
    ON em."ExternalManagerConfigId" = emc."Id"
INNER JOIN "ClientSolutions" AS cs 
    ON cs."AmsId" = em."LegacySolutionId";



foreach (var cs in externalManagerConfig.ExternalManagerClientSolutions)
{
    var payload = JsonConvert.SerializeObject(new
    {
        notification.ExternalManagerCode,
        cs.ClientSolutionId,
        cs.StartDate,
        cs.EndDate
    });

    var outboxMessage = new OutboxMessage(
        DestinationType.Internal,
        MessageType.ExternalManagerClientSolution,
        payload,
        ExternalManagersConstants.DefaultVersion,
        ExternalManagersConstants.DefaultMessageGroupId
    );

    await _externalManagerDataDistributionRequestService.QueueDataDistributionRequest(
        outboxMessage, cancellationToken);
}



foreach (var cs in clientCashFlowGroup.LiabilityCashflowClientSolutions)
{
    var payload = JsonConvert.SerializeObject(new
    {
        notification.LiabilityCashflowGroupCode,
        cs.ClientSolutionId,
        cs.StartDate,
        cs.EndDate,
        notification.ClientCurveGroupId,
        notification.ClientId,
        notification.ImplementationDate,
        notification.TerminationDate,
        PensionScheme = notification.PensionScheme.ToString(),
    });

    _logger.LogInformation($"Queuing Cashflow LiabilityCashflowClientSolution message for " +
                          $"LiabilityCashflowGroupCode[{notification.LiabilityCashflowGroupCode}], " +
                          $"StartDate[{cs.StartDate.ToShortDateString()}], " +
                          $"ClientCurveGroupId[{notification.ClientCurveGroupId}]");

    await _cashFlowDataDistributionRequestService.QueueDataDistributionRequest(
        payload, DestinationType.Internal, MessageType.LiabilityCashflowClientSolution, cancellationToken);
}



SELECT 
    emc.id AS ExternalManagerConfigId,
    COUNT(em.id) AS ExternalManagersCount
FROM externalmgr."ExternalManagerConfigs" emc
LEFT JOIN externalmgr."ExternalManagers" em 
    ON em."ExternalManagerConfigId" = emc."id"
GROUP BY emc.id
ORDER BY ExternalManagersCount DESC;

SELECT 
    emc.id AS ExternalManagerConfigId,
    STRING_AGG(em.id::TEXT, ', ') AS ExternalManagerIds
FROM externalmgr."ExternalManagerConfigs" emc
LEFT JOIN externalmgr."ExternalManagers" em 
    ON em."ExternalManagerConfigId" = emc."id"
GROUP BY emc.id
ORDER BY emc.id;



SELECT 
    emc.id AS ExternalManagerConfigId,
    COUNT(emcs.id) AS ClientSolutionsCount
FROM externalmgr."ExternalManagerConfigs" emc
LEFT JOIN externalmgr."ExternalManagerClientSolutions" emcs 
    ON emcs."ExternalManagerConfigId" = emc."id"
GROUP BY emc.id
ORDER BY ClientSolutionsCount DESC;


SELECT 
    emc.id AS ExternalManagerConfigId,
    STRING_AGG(emcs."ClientSolutionId"::TEXT, ', ') AS ClientSolutionGroups
FROM externalmgr."ExternalManagerConfigs" emc
LEFT JOIN externalmgr."ExternalManagerClientSolutions" emcs 
    ON emcs."ExternalManagerConfigId" = emc."id"
GROUP BY emc.id
ORDER BY emc.id;


Send the entire payload and the array of EMClientSolutionsAssociations in the "ExternalManagerConfiguration" message.

Once BMK and ALPHA consume the "ExternalManagerConfiguration" message, perform an internal publish by iterating over the array of EMClientSolutionsAssociations so that the "ExternalManagerClientSolution" message is self-consumed.

And the same for Cashflows. The goal is that always EMClientSolutionsAssociations proceeds before ExternalManagerClientSolution


public async Task<ExternalManagerConfig> GetClientSolutionsByIdAsync(int Id)
{
    var query = _dbContext.ExternalManagerConfigs
        .AsNoTracking()  // Agregar AsNoTracking para mejorar rendimiento en lectura
        .Include(emc => emc.ExternalManagerClientSolutions);

    return await query.SingleOrDefaultAsync(emc => emc.Id == Id);
}










int? externalManagerConfigId = notification.ExternalManagerConfigId;
if (!externalManagerConfigId.HasValue)
    return;

var clientSolutions = await _externalManagerConfigRepository
    .GetClientSolutionsByIdAsync(externalManagerConfigId.Value);

if (!clientSolutions.Any())
    return;

var tasks = clientSolutions.Select(item => 
{
    var payload = JsonConvert.SerializeObject(new
    {
        notification.ExternalManagerCode,
        item.ClientSolutionId,
        item.StartDate,
        item.EndDate
    });

    var outboxMessage = new OutboxMessage(
        DestinationType.Internal, 
        MessageType.ExternalManagerClientSolution, 
        payload,
        ExternalManagersConstants.DefaultVersion, 
        ExternalManagersConstants.DefaultMessageGroupId
    );

    return _externalManagerDataDistributionRequestService
        .QueueDataDistributionRequest(outboxMessage, cancellationToken);
}).ToList();

// Ejecuta todas las tareas en paralelo
await Task.WhenAll(tasks);














    int? externalManagerConfigId = notification.ExternalManagerConfigId;
    if (!externalManagerConfigId.HasValue)
        return;

    var externalManagerConfig = await _externalManagerConfigRepository
        .GetClientSolutionsByIdAsync(externalManagerConfigId.Value);

    if (!externalManagerConfig.ExternalManagerClientSolutions.Any())
        return;

    var tasks = externalManagerConfig.ExternalManagerClientSolutions
        .Select(item =>
        {
            var payload = JsonConvert.SerializeObject(new
            {
                notification.ExternalManagerCode,
                item.ClientSolutionId,
                item.StartDate,
                item.EndDate
            });

            var outboxMessage = new OutboxMessage(
                DestinationType.Internal,
                MessageType.ExternalManagerClientSolution,
                payload,
                ExternalManagersConstants.DefaultVersion,
                ExternalManagersConstants.DefaultMessageGroupId
            );

            return _externalManagerDataDistributionRequestService
                .QueueDataDistributionRequest(outboxMessage, cancellationToken);
        });

    await Task.WhenAll(tasks);
