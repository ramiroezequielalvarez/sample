Con respecto a "Npgsql.EnableLegacyTimestampBehavior", el origen del problema, surge en la migracion de 3.1 a NET 6.

Como parte de la actualizacion a .NET 6, actualizé el paquete npgsql de efcore a la ultima version 6.x. Uno de los mayores cambios de la version 6.x es como se manejan los timestamps. Si el tipo en la base de datos es timestamp without timezone entonces se debe mapear todos los DateTime a DateTime.Kind == DateTimeKind.Local (or DateTimeKind.Unspecified) on the C# side. 

Si el tipo de dato es timestamp with timezone then we must map it to a DateTime object with DateTime.Kind == DateTimeKind.Utc on the C# side. 

Ademas, al correr una migration, automaticamente se convierte todo a "timestamp with time zone". 

Como es un cambio importante a realizar, y no quiero impactar a las fechas, por el momento preferi dejar el comportamiento anterior. Y luego se puede crear un tech-debt en core.

###
Regarding "Npgsql.EnableLegacyTimestampBehavior", the source of the problem, arises in the migration from 3.1 to .NET 6.

As part of the upgrade to .NET 6, I upgraded the efcore npgsql package to the latest 6.x version. One of the major changes in version 6.x is how timestamps are handled. If the type in the database is timestamp without timezone (first image - default) then you must map all DateTime to DateTime.Kind == DateTimeKind.Local (or DateTimeKind.Unspecified) on the C# side. 

If the data type is timestamp with timezone then we must map it to a DateTime object with DateTime.Kind == DateTimeKind.Utc on the C# side. 

When running a migration in NET 6, it automatically converts everything to "timestamp with timezone". (second image)

As it is an important change to make, and I don't want to impact the dates, for the moment I preferred to leave the previous behavior. And then you can create a tech-debt in sigma core.

##




https://duongnt.com/datetime-net6-postgresql/

Migration from 3.1 to NET 6

Cannot write DateTime with Kind=Unspecified to PostgreSQL type 'timestamp with time zone', only UTC is supported.

As part of moving the project to .NET 6, I upgraded the the npgsql efcore provider to the latest 6.x version. One of the biggest changes in version 6.x is how timestamps are handled. If the type in the database is timestamp with timezone then we must map it to a DateTime object with DateTime.Kind == DateTimeKind.Utc on the C# side. 

"Npgsql.EnableLegacyTimestampBehavior"





Note that it's not possible to mix DateTimes with different Kinds in an array/range. See the Npgsql.EnableLegacyTimestampBehavior AppContext switch to enable legacy behavior.

As part of moving the project to .NET 6, I upgraded the the npgsql efcore provider to the latest 6.x version. One of the biggest changes in version 6.x is how timestamps are handled. If the type in the database is timestamp with timezone then we must map it to a DateTime object with DateTime.Kind == DateTimeKind.Utc on the C# side. 

Conversely, we must map the type timestamp without timezone to a DateTime object with DateTime.Kind == DateTimeKind.Local (or DateTimeKind.Unspecified). At first glance, I thought I was writing a DateTimeKind.Local/DateTimeKind.Unspecified object into a timestamp with timezone column in the database . But that didn’t sound right for two reasons.

I confirmed that the database is using timestamp without time zone.

